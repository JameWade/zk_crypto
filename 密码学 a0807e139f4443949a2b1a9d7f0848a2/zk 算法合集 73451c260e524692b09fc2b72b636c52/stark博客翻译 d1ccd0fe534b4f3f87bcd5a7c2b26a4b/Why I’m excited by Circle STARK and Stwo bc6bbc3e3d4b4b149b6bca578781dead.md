# Why I’m excited by Circle STARK and Stwo

自以太坊推出 STARK 以来，上个月发表的研究成果是最令人兴奋的扩展突破之一。这项研究的数学原理很复杂，但它使用了经典的round-shaped circle（见图 1），将 STARK 的证明能力提高了 100 倍甚至更多。

![Untitled](Why%20I%E2%80%99m%20excited%20by%20Circle%20STARK%20and%20Stwo%20bc6bbc3e3d4b4b149b6bca578781dead/Untitled.png)

这项研究由 Polygon 实验室的 Ulrich Haböck 与 StarkWare 的 David Levit 和 Shahar Papini 合作完成。很多人都会用到这项研究，StarkWare 也很荣幸能通过构建和开源 Stwo 检验器，迅速将其投入实际应用。在本文中，我将尝试用我能想到的最简单的方式来解释数学及其意义。

# **STARK Scalability and Transparency**

STARK 定义了一套确保计算完整性的协议，特别强调了可扩展性和透明度--分别是 STARK 中的 "S "和 "T"。可扩展性涉及以快速、经济高效的方式生成和验证计算完整性证明，使公众能够在不依赖大量或昂贵流程的情况下使用计算完整性证明。这一属性对于在不同实体间应用完整性检查至关重要，并推动了 StarkWare 在区块链计算方面的改进。

STARKs 的透明度意味着消除 "可信设置"；所有程序都基于公开随机性，减少了信任假设。这一点对于维护计算完整性至关重要，尤其是针对可能利用系统参数的有影响力实体。可扩展性和透明度共同定义了 STARK 技术的核心，提供安全、可扩展、透明和公开的验证方法。确保验证系统遵守这些原则对于保持有效和可靠的运行至关重要。无论您将自己的系统称为 STARK 还是其他名称，都要了解 "可扩展性 "和 "透明度 "这两个双管齐下的原则所带来的显著优势，并询问你的本地证明者，其证明系统是否同时具备这两个特性。

# **STARK Efficiency Means Small “Numbers”**

在本节中，我将论证计算效率意味着你需要塑造你的证明系统，使其最符合现代计算机的性能特征。这需要我们使用一个特殊的素数—— $2^{31}-1$

在实践中实施的所有证明系统（以及多年来在数学上发现的几乎所有证明系统），都是通过生活在 "有限域 "数学世界中的特殊 "数 "来运行的。有限域有很多（无穷多！），但让我们把重点放在最简单的成员上，它们被称为 "质域"。质数域由一个质数 p（如 5）定义，其“数”包括 $0，1,…,p-1$)（因此，如果 p=5,我们的 "数 "是 $0,1,2,3,4$ ）。

在有限域中进行加法和乘法运算时，首先按标准方法进行加法和乘法运算，然后在除以 $p$。因此，当 $p=5$，我们有 $3+3=1$(6除以5的余数),和 $3*3=4$(9除以5的余数)。缩写为 $3+3=1 mod 5$,和 $3*3=4 mod 5$

有限域的一个重要优势是，它们的大小是有限的。这意味着你永远不必担心分数、浮点运算和任意大的整数。你唯一能遇到的 "数字 "是 $0,1,…,p-1$。因此，因此，如果你的素数比标准计算机字小，你就能把每个 "数 "都装进标准计算机字里，这样就能节省空间（计算机字长为 32 位。在进行加法或乘法运算时，您大多也会使用 32 位字。

Stone 是第一个投入生产的 STARK 证明系统，过去四年来一直在扩展以太坊，为客户节省了超过 10 亿美元的费用。它是在一个非常大的素数域上定义的，这个素数域的大小大约为 $2^{252}$,这意味着存储一个 "数字 "需要 8 个计算机字（每个字 32 位）。“大数 "的加法运算，尤其是乘法运算，需要耗费大量的计算机周期。准确地说，在 Stone 中，我们每次乘法平均要花费 38 个周期。上周公布的 Stwo 使用了一个较小的素域 $2^{31}-1$，由梅森素数定义，代号为 M31。这意味着你可以在一个计算机字内的字段中存储一个 "大数"，乘法运算的速度也会更快。使用矢量化运算，我们每次乘法的时钟周期为 0.3 个周期，比我们在 Stone 中的运算速度快 125 倍！（矢量化运算对 Stone prime没有帮助）

有很多质数适合放在 32 位字内(质 5 是其中之一），但是应当使用接近 $2^{32}$的数。还有许多其他素数可供选择，但梅森素数 M31= $2^{31}-1$ 的特殊之处在于，对它进行某些运算非常高效，因为数字 $2^{31}$（二进制数 1,000,000,000,000,000,000,000,000， 1 后面有 30 个零）等于 1 modulo M31。与另一个流行的 "小 "质数，即所谓的 "Babybear 质数"（由 Risc0 使用） $2^{31}-2^{27}+1$ 相比，在矢量化机器上， M31 乘法的速度比Babybear 乘法快大约1.3 倍。因此，我们非常希望在 M31 素域上构造我们的 STARK，但有一个问题…

# **Efficiency Means Nice Multiplicative Structure**

有限域有很多结构。例如，如果你只考虑加法，并开始将一个数字（0 除外）加到它本身，你会发现你覆盖了该领域的所有数字，然后又回到了起点。例如，在素数 5 定义的域中，如果我们重复加上 2，就会得到这样的序列： $2,4,1,3,0,2,4,1,3,0,…$然后是{2，4，1，3，0}基础序列重复。素数域的一个有趣事实是，无论从哪个非零数开始，基本循环序列的长度都是 $p$

到了乘法运算，情况就不一样了。我们总是会得到循环结构，但其周期长度取决于我们从哪个数字开始。如果我们从 2 开始( 仍然是p=5)，我们就会产生长度为 4 的序列 $2, 4, 3, 1, 2, 4, 3, 1, ......$,但数字 4 产生的序列 $4,1,4,1,4,1,......$的周期长度为 2、而数字 1 产生的序列 $1,1,1,1......$的周期长度为 1。

要实现高效的 STARK，关键是要在域内选择一个数字 $g$，通过重复乘法，产生一个明显较长的基本序列——最好超过 1,000,000.但是你还需要这个模式的大小是 2 的精确整数幂，比如 $2^{20}$..如果你想知道为什么我们需要这种奇怪的 "2 的幂次 "长度，那是因为这种结构的序列有许多相似的子结构，它们就像分形图案一样，一个藏在另一个里面。我的意思是:如果 $g$生成一个长度为 $2^{20}$的基本循环模式，那么 $g^2$生成的基本循环序列是第一个模式中的每一个数字，且大小为 $2^{19}$,而 $(g^2)^2=g^4$生成的基本循环序列长度为 $2^{18}$，以此类推。  注意到我们在前面已经举国例子： $2,4(=2^2),1(=4^2)$，在模5的情况下。如果你还想知道为什么我们需要这种 "子序列 "属性，你需要阅读更多的资料，特别是关于递归算法和神奇而无处不在的快速傅立叶变换（FFT）及其数论变换（NTT）的资料。

因此，我们需要的是梅森域（ $2^{31}-1$）内的一个生成元 $g$,使其产生的乘法序列的长度是 2 的大幂次(比如 $2^{20}$).唉，不存在这样的g！事实证明，在一个大小为p的有限域内，重复出现的的乘法序列的长度必须整除 $p-1$(前文中2和4都整除 5-1)。但是对于梅森素数来说 $p-1 = 2^{31}-2$,然而没有一个2的大数次幂整除这个数。事实上，  $2^{31}-2$ 的最大整除幂就是 2。（详阅群论）

我们似乎陷入了困境。我们需要一个能在梅森场内产生特定模式的生成元 $g$，但我们也知道，数学上不存在这样的生成元。

# **Think Outside the Box (or Field)**

数学的魅力之一在于它能够提供概括性的知识，从而拓宽我们的理解，完善我们的解决方案。到目前为止，我们主要讨论了单个数字 $g$ 的简单相乘所产生的序列。但是，我们可以定义由成对数字产生的序列，这正是我们在构建圆 STARK 时要做的。点（x,y）是位于圆上的，如果 $x^2+y^2=1$.我们通常会把这些点想象成位于古老的圆圈上，但数学家的想法却不同。请注意，如果我们在 5 所定义的素数域中工作那么 $4^2+0^2=1$,因此“点”（4，0）在圆上。这也是点（-1，0），因为在域中4和-1是一样的，如果你对他们加1，他们都等于0。我们可以确定圆上的四个点:（0，1），（-1，0），（0，-1），（0，1）。我们可以使用 $(g_x,g_y)=(0,1)$生成上面所有的点。不像上文说的使用 $x_i$生成 $x_{i+1}$的方式 $x_{i+1}=g * x_i$，我们现在使用点 $(x_i,y_i)$在圆上移动：

$(x_{i+1},y_{i+1}) = (g_x *x_i - g_y*y_i, g_x * y_i + g_y * x_i)$

这样如果我们用点 $(x_0,y_0) =(1,0)$，并且在它上面应用上述规则，通过生成元 $(g_x,g_y)=(0,1)$，我们可以得到循环序列 $(1,0),(0,1),(-1,0),(0,-1)$…

在研究素数 5 时，我们的收获并不大，因为我们已经知道如何通过简单的乘法产生长度为 4 的循环序列。现在我们考虑素数31。因为 $31-1=30=2*3*5$,能被 2 的幂整除的最长序列是长度为 2 的序列。但是在圆上，我们可以找到 $32=2^5$这样的点，通过上述规则，由 $(g_x,g_y) = (2,11)$生成，起始点为 $(x_0,y_0) = (1,0)$  `没看懂`

事实证明，在梅森素数 $2^{31}-1$上定义的圆上的点的数量相当大。大小为 $2^{31}$。你可以生成所有的 $2^{31}$个数，从 $(x_0,y_0)=(1,0)$开始，应用生成元 $(g_x,g_y)=(2,1268011823)$，使用上面的规则。

那么，这一切会给我们带来什么：我们可以使用超高效的梅森域进行算术运算——乘法运算速度是 252 位 Stone域的 125 倍，是类似大小的 Babybear 域乘法运算速度的 1.3 倍。此外，我们还找到了必要的重复结构（数学上称为 "代数循环群"），它的规模很大，并且是 2 的精确幂次，从而产生了规模为 ½ 、 ¼ 等的重复子结构，以及与之相关的快速递归算法。

# **From Circle STARK to Stwo?**

Stwo（"STARK Two"）是星网下一代验证器的名称，它将增强、加快并最终取代当前的验证器--Stone（"STARK One"）。Stwo 的效率预计是 Stone 的 100 倍，它将使用比 M31（如上所述）更多的环形 STARK。其他创新还包括 “log-up”和sum-check 协议（in [this recent work](https://eprint.iacr.org/2023/1284) by Haböck and Papini）、同时处理多个不同度数的多项式（"混合度数"），以及用于编码电路和虚拟机的新基础设施。因此，STARK 验证规模的预期改进大约是 Stone 的 100 倍，同时还能带来更多好处，如更灵活地采用新编译器和虚拟机，从而提高开发速度。[点击此处](https://starkware.co/resource/stwo-prover-the-next-gen-of-stark-scaling-is-here/)了解有关 Stwo 的更多信息。

# **KZG Commitments and Pairing-Based SNARKs?**

KZG 承诺是 Stone、Stwo 和其他 STARKs 使用的 FRI 协议的主要竞争对手，也是许多基于配对的 SNARKs 的数学基础。它们的主要优势在于最终证明极其简洁，只需约 200 字节即可完成((而 FRI 和当前的 STARK 需要几千字节）。它们的另一个优势是，可以通过 DankSharding 在以太坊上对特定的 KZG 参数设置进行预编译，并集成到以太坊核心协议中。这解释了为什么许多 STARK 系统（如 Polygon、RiscZero 和 ZKsync 使用的系统）最终都被包裹在 SNARK 系统内——以利用特定的以太坊预编译。只要对某些证明系统有特定的补贴，就会有更多相同的情况出现--团队会考虑将他们的 STARK 包装在 SNARK 内。但是，与 KZG 安全素数相比，M31 的乘法运算速度要快 100 倍甚至更多（目前的最佳实践要求此类素数需要 380 多比特！），因此 KZG 和基于配对的系统在规模和吞吐量方面不太可能像 Stwo 那样高效。虽然椭圆曲线数学领域和基于配对的 SNARK 的创新范围令人叹为观止，但我们应该记住，这种 SNARK 不仅效率低下，而且需要可信设置，容易受到量子计算机的攻击。换句话说，就效率、安全性和面向未来性而言，基于小型有限域的 STARK 是更好的选择。

# **Parting Thoughts**

Circle STARK 标志着 STARK 技术领域令人兴奋的进步，它已经从理论过渡到实践。它们是 STARK 证明不断发展的最新里程碑，STARK 证明正变得越来越复杂。随着我们向前迈进，这些证明必将迎接新的挑战，并开启超出我们目前想象的应用。

很高兴看到令人惊叹的深奥数学出现在系统中，这些系统将以数量级的方式扩展区块链。区块链中被称为 "ZK "的领域不止一次地采用了最前沿的 "月球数学（moon math）"，并以此打造出创新产品。例如，Zcash 拥有首个用于通用电路的 ZK-SNARK 系统，可在区块链上提供金融隐私；STARKs 是以太坊上首个最高效、面向未来的扩展技术；Cairo 是用于编写可证明代码的下一代智能合约语言。因此，我非常期待看到 Circle STARKs 和 Stwo 将带来哪些不可预见的奇妙应用和新数学。