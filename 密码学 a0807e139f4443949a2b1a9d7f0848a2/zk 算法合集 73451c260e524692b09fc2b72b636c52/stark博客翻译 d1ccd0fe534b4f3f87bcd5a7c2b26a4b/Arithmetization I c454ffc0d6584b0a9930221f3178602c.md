# Arithmetization I

这是系列文章的第二篇。

读完本篇文章后，您应该对 `*execution trace`* 和 `*polynomial constraints`* 有了一定的了解，并知道计算完整性语句是如何转化为这些约束的。我们将从 supermarket receipt这个简单的例子开始，进而讨论一个稍微复杂一点的例子，即Collatz sequences，它与数论中一个著名的开放性问题有关。我们将假定对有限域上的多项式和整数的二进制表示法有基本的了解。

# **STARK in Broad Strokes**

STARK 协议的目标是简洁(succinctly )透明地(transparently)验证计算。STARK 的第一步称为算术化，它是将验证计算的问题转换（通常称为 "reduction"）为检查某个多项式是否为低度多项式的问题（这是 "succinctly"的部分）。算术化是非常有用的，因为它可以使用纠错码领域的工具，有效地测试低度数。然而，算术化本身只是将计算完整性声明转化为多项式，为 STARK 的下一阶段做好了准备，STARK 是另一个交互式协议，涉及证明者试图说服验证者多项式确实是低度多项式。只有当且仅当原始计算是正确的（除了无限小的概率），验证者才会相信多项式是低度的。在 STARK 的最后一步中，交互式协议被转化为单一的非交互式证明，该证明可以发布到区块链上，并由任何人进行公开验证。

算术化分为两部分：第一部分是生成执行轨迹和多项式约束条件，第一部分是将这两个对象转换成一个低度多项式。在证明者与验证者的交互过程中，真正的情况是证明者和验证者事先就多项式约束条件达成一致意见。证明者随后生成一个执行轨迹，在随后的交互中，证明者试图说服验证者，在验证者看不到的情况下，多项式约束条件在这个执行轨迹上得到了满足。 `所谓的执行轨迹就是电路`

# **Recap — Computational Integrity Statements**

在上一篇文章中，我们讨论了计算完整性（CI）声明的概念，即从抽象的角度宣称某种计算的输出是正确的。让我们来看一个 CI 语句的具体例子：我们在超市应该支付的总金额计算正确。这种说法的传统证明就是收据。通常情况下，收据中的项目会列出其价格，总金额会显示在底部，就像这样：

![Untitled](Arithmetization%20I%20c454ffc0d6584b0a9930221f3178602c/Untitled.png)

为简单起见，我们仅将其视为求和正确的声明。要想知道这个 CI 语句是否成立，我们可以浏览一下清单--不跳过任何一个项目--计算出总金额，然后与收据底部的数字进行核对。这是一个非常简单的例子，但我们将在本文的后面部分用它来演示 `*succinct testability*`简洁可测试性的理念。

# **Arithmetization**

运算的第一步是获取一些 CI 语句（例如 "区块 7218290 中的第五笔交易是正确的),并将其转化为形式化的代数语言。这样做有两个目的：1)简洁地做出声明，2）将声明嵌入到代数域。这种嵌入使得算术化的第二步得以实现，它将 CI 语句简化为对特定多项式度数的声明。

我们使用的代数表示法有两个主要部分：1) 执行轨迹，2）一组多项式约束条件。执行轨迹是一个表示底层计算步骤的表格，其中每一行表示一个步骤。多项式约束条件集的构造是，当且仅当轨迹表示有效计算时，所有约束条件都得到满足。虽然执行轨迹可能很长，但我们将使用一组简洁的多项式约束。

# **Execution Trace**

我们希望生成的执行轨迹类型必须具有可简洁测试的特性 —— 每一行的验证只能依赖于轨迹中与之相近的行，且每对行都采用相同的验证程序。这一特征直接影响到证明的大小。为了说明 "简洁可测试 "的含义，让我们回到超市的收据上，再增加一栏来表示流水总数：

![Untitled](Arithmetization%20I%20c454ffc0d6584b0a9930221f3178602c/Untitled%201.png)

通过这一简单的加法，我们就可以根据前一行的情况单独验证每一行。

例如，我们可以检查这两行：

![Untitled](Arithmetization%20I%20c454ffc0d6584b0a9930221f3178602c/Untitled%202.png)

并确信这一步计算（即数字 16.41）是正确的，因为 12.96+3.45=16.41.请注意，每一对行都采用了相同的约束条件。这就是我们所说的简洁约束。

# **Polynomial Constraints**

让我们用表格的形式重写超市收据（附带流水账）：

![Untitled](Arithmetization%20I%20c454ffc0d6584b0a9930221f3178602c/Untitled%203.png)

用 $A_{i,j}$ 表示第 i 行第 j 列单元格的值,现在，我们可以将正确性条件改写为这组多项式约束条件：

1. $A_{0,2} = 0$         金额计算起点是0
2. $\forall  1 \le i \le 5: A_{i,2} - A_{i-1,2} - A_{i-1,1} = 0$    保证每一行计算正确
3. $A_{5,1} - A_{5,2} =0$                                            保证最后计算的和正确
4. 

这些都是 $A_{i,j}$ 中的线性多项式约束。如果我们使用的多项式约束条件的度数较高，则会对证明长度和生成证明所需的时间产生不利影响.因此，线性约束是我们所能期待的最好结果。请注意，(2) 实际上是多次应用的单一约束，整个集合的大小与收据的长度无关。

总之，我们将验证超市收据的 CI 问题转化为一个简洁的可测试执行跟踪，以及一组相应的多项式约束，当且仅当原始收据中的总和正确时，这些约束才成立。

让我们来看一个更复杂的例子。

# **Collatz Conjecture**

1937 年，德国数学家Lothar Collatz在数论领域提出了一个猜想。乍一看，这个猜想可能只是一个可爱的数学题，但事实上，它是数论中的一个难题。多年来，它引起了许多数学家的注意，并获得了许多同义词(the 3*n* + 1 conjecture, the Ulam conjecture, Kakutani’s problem and many more).关于这个猜想，保罗-厄尔多斯曾经说过："数学可能还没有准备好应对这样的问题"。

科拉茨数列以任意正整数开头，数列中后面的每个元素都是从前面的元素中按如下方式得到的：

1. 如果前一个元素是偶数：除以 2。
2. 如果前一个元素是奇数且大于 1：乘以 3 再加 1。
3. 如果前一个元素为 1，则停止。

我们来看一个简单的例子，初始项为 52：

52 -> 26 -> 13 -> 40 -> 20 -> 10 -> 5 -> 16 -> 8 -> 4 -> 2 -> 1.

科拉茨猜想：对于任何正整数，我们开始时的序列总是到达 1。

解决科拉茨猜想超出了本篇博文的范围。相反，我们将考虑验证针对特定起始整数的猜想的计算问题。

# **The Collatz Sequence Execution Trace**

CI 语句是"一个以 52 开头的科拉茨数列，迭代 11 次后以 1 结尾"。

让 A 成为序列计算的执行轨迹。第 i 行以 $A_i$ 表示，代表序列中的第 i 个数字。所有数字都用二进制字符串表示，以便于用多项式表达奇数/偶数条件。 $A_{i,j}$ 等于序列中第 i 个数字的第 j 个最小有效位。例如，A0=001011：第一项是 52，它的二进制表示法是 110100，然后我们颠倒位的顺序（位反转顺序简化了多项式约束符号的索引过程）

![Untitled](Arithmetization%20I%20c454ffc0d6584b0a9930221f3178602c/Untitled%204.png)

请注意，这里的轨迹有 6 列，因为即使是序列中最大的数字，6 个比特也足以表示。如果我们从 51 开始，下一个数字将是 154，因此这样一个序列的轨迹至少需要 8 列。

# **The Collatz Sequence Polynomial Constraints**

回想一下，我们要寻找的多项式约束条件是，当且仅当迹线 A 描述了给定的科拉茨序列时，所有这些约束条件都得到满足（(从 52 开始，以 1 结束，任何连续两行的过渡都是正确的）。在我们的例子中，轨迹 A 的大小为 6x12，即表示一个由 12 个 6 位数组成的科拉茨序列。多项式约束条件集如下（n=12，m=6）：

1.  $\sum_{j = 0}^{m-1}2^jA_{0,j}-first Term = 0$      //第一个数是52，这个公式就是验证二进制表示的第一个数是52
2. $\sum_{j = 0}^{m-1}2^jA_{n-1,j}-1 = 0$              //验证二进制表示的最后一个数是1
3. $\forall   i < n,\forall j<m:A_{i,j}^2-A_{i,j} = 0$          //保证表格内的数是二进制数（bit位）
4. $\forall i < n-1 : A_{i,0}[3\cdot(\sum_{j=0}^{m-1}2^j\cdot A_{i,j})+1-\sum_{j=0}^{m-1}2^j\cdot A_{i+1,j} ]  + (1-A_{i,0}) \cdot [\sum_{j=0}^{m-1}2^j \cdot A_{i,j} - 2 \cdot(\sum_{j=0}^{m-1}2^jA_{i+1,j})]$                                  //链接表格两行的公式

让我们逐一来看看这些约束条件。前三个简单明了：

1） 当且仅当第一行是 52 的二进制表示时 成立。

2） 当且仅当最后一行是 1 的二进制表示时成立。

3） 当且仅当轨迹只包含比特时成立（当且仅当一个数字为 0 或 1 时，该数字等于它的平方）。

第四组约束定义了序列简洁计算的核心，即每两个连续行之间的连接。将计算约束表达为局部约束的重复模式（即简洁性）的能力，是验证器比单纯地重放计算快数倍的根本所在。

让我们仔细研究一下制约因素本身。

对于任意 i<n-1，表示：

$P_i^{ood} = 3\cdot(\sum_{j=0}^{m-1}2^j\cdot A_{i,j})+1-\sum_{j=0}^{m-1}2^j\cdot A_{i+1,j}$    当 $A_i$是偶数时成立

$P_i^{even} =   \sum_{j=0}^{m-1}2^j \cdot A_{i,j} - 2 \cdot(\sum_{j=0}^{m-1}2^jA_{i+1,j})$             当 $A_i$是奇数时成立

因此，对于每个 i<n-1，我们可以得到以下约束条件：

$A_{i,0} \cdot P_i^{odd} + (1-A_{i,0}) \cdot P_i^{even} =0$

Ai,0 是第 i 个数字的最小有效位，它决定了数字作为整数的奇偶校验，因此这一约束条件描述了科拉茨序列规则。

总之，当且仅当轨迹代表科拉茨序列的有效计算时，所有约束条件才会得到满足。

请注意，任何长度为 n 的科拉茨序列都可以用大小为 n*m 的轨迹来表示，其中 m 是序列中数字表示的最大位数，相应的多项式约束条件也会相应修改。请注意，多项式约束条件不会随 n 和 m 的增加而增加，而是保持简单明了

给定科拉兹序列的特定首项，一个简单的计算机程序就能输出执行轨迹和多项式约束条件。

# **Conclusion**

在这篇文章中，我们介绍了 CI 语句算术化的第一步。

我们已经看到关于科拉茨序列的 CI 语句是如何转化为执行轨迹和一组简洁描述的多项式约束的。类似的方法可用于转换任何计算，一般来说，任何 CI 语句都可以转换成这种形式。不过，细节问题非常重要。虽然执行轨迹（和一组多项式约束）可以通过多种方式来描述特定计算，但其中只有少数方式可以生成小的 STARK 证明，并且可以高效地构建。StarkWare 的大部分精力都投入到了设计能带来良好多项式约束的还原方法上，我们称之为 AIR（代数中间表示法），因为我们系统的大部分性能都取决于它。

在下一篇文章中，我们将介绍算术化的第二步--将执行轨迹和多项式约束条件转化为一个单一的多项式，这个多项式保证是低度多项式，前提是且仅当原始计算是正确的。