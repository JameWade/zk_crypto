# zkSNARKs 的底层——PLONK 协议：第 1 部分

PLONK 是属于 SNARK 系统的零知识证明系统之一。与较早的 Groth16 系统相比，PLONK 具有以下优势：通用且可更新的可信设置。在 Groth16 中，需要针对特定电路（或特定任务，对于不熟悉该术语的人）进行可信设置，而在 Plonk 中，相同的设置可重复用于任何电路。“可更新”一词是指任何人都可以为设置添加随机性，从而增强对其完整性的信任。

不过，PLONK 的一个缺点是会导致证明规模增大，从而影响以太坊网络的gas成本。这也是 Groth16 仍被认为具有竞争力的潜在原因。

PLONK 协议封装了各种不同的技术，在深入了解协议本身之前，必须先了解其中的一些技术。让我们从基础知识开始。

# 多项式

多项式是零知识证明系统的基本要素之一。我们中的许多人都在学校学过它们，但它们在这里的应用可能并不明显。为什么要使用它们？

![Untitled](zkSNARKs%20%E7%9A%84%E5%BA%95%E5%B1%82%E2%80%94%E2%80%94PLONK%20%E5%8D%8F%E8%AE%AE%EF%BC%9A%E7%AC%AC%201%20%E9%83%A8%E5%88%86%202586002046bb457cb9365b27ef552368/Untitled.png)

多项式提供了一种形式，让我们可以将特定过程的状态封装在一个函数中。这是我对其作用的简化理解。因此，当我们想要证明某些事情时，例如程序执行的正确性或语句的验证，我们可以用多项式来表示这些过程。这一显著特点使我们能够构建复杂的证明系统。

# KZG/Kate多项式承诺方案

简而言之，Plonk 采用 KZG（Kate、Zaverucha、Goldberg）方案进行验证。让我们看一个玩具例子来了解承诺方案是如何工作的

## setup 阶段：

- 爱丽丝有自己想做的事情，比如她决定去哪里吃晚饭。假设她选择了 "意大利菜"。
- 她把自己的选择写在一张纸上。

## **Commit 阶段**:

- 爱丽丝把纸放在一个盒子里。
- 她用挂锁锁上了盒子，并保管好钥匙。
- 她把上锁的盒子交给鲍勃，向他保证她的晚餐选择就在里面。
- 此时，鲍勃拿到了装有承诺书的盒子，但由于盒子上了锁，他无法打开。

## **Reveal 阶段**

- 到了揭晓她的晚餐选择的时候，爱丽丝把钥匙交给了鲍勃。
- 鲍勃打开盒子的锁，拿出那张纸，读出了爱丽丝的晚餐选择："意大利菜"。
- 鲍勃现在知道了爱丽丝的承诺，而且他确信爱丽丝在把上锁的盒子交给他之后并没有改变主意，因为盒子一直被牢牢地锁着。

在 KZG 承诺方案中，证明者承诺一个多项式（例如，代表程序执行的正确性）。

假设验证者需要commit一个度数为 n 的多项式 P(x)。为此，他需要一个可信设置。有关可信设置的更多信息，请参阅以下资料：

[**Trusted Setup in zkSNARKs— Powers of Tau vs Lagrange basis**](zkSNARKs%20%E7%9A%84%E5%BA%95%E5%B1%82%E2%80%94%E2%80%94PLONK%20%E5%8D%8F%E8%AE%AE%EF%BC%9A%E7%AC%AC%201%20%E9%83%A8%E5%88%86%202586002046bb457cb9365b27ef552368/Trusted%20Setup%20in%20zkSNARKs%E2%80%94%20Powers%20of%20Tau%20vs%20Lagran%20b2a4a076a9704af2b13a89e57f098f64.md)

这里的可信设置指的是生成随机秘密值的幂次，τ (tau)，至多n阶。然后，这些幂被 "掩盖"或表示为椭圆曲线上的点。如果你对椭圆曲线点不熟悉，可以把它们看成是秘密值 τ 与曲线上一个基点的乘积，它掩盖了 τ 的实际值。这一过程可以防止任何人推断出原始秘密值，这对系统的安全性至关重要。

$CRS = \lbrace G, {\tau}^1G,{\tau}^2G,….,{\tau}^nG \rbrace$

多项式承诺如下：

$P(\tau) = c_0[G] + c_1[\tau G] + c_2[\tau^2G]+…+c_n[\tau^nG]$

中括号表示椭圆曲线上的点

$P(\tau) = (c_0 + c_1 \tau + c_2 \tau^2+…+c_n\tau^n)[G]$

证明者使用从可信设置中获得的通用参考字符串计算多项式 P(τ) 的承诺，并将该承诺（椭圆曲线上的一个点）发送给验证者。 `这里证明者手里有的是多项式系数`

这是因为曲线基点 [G] 的标量倍数（如 cτ）的结果是曲线上的另一个点。验证者会收到 P(τ) 的承诺，但为了保持零知识属性，实际的多项式 P(x) 不会被揭示。

取而代之的是，验证者向证明者发送一个随机值 r，然后证明者在该点计算 P(x)，并继续执行协议。

$P(r) = c_0+c_1r+c_2r^2+…+c_nr^n$

证明者将求值 P(r) 返回验证者。验证者现在有了承诺 P(τ)、求出的 P(r)，以及多项式余数定理（在这种情况下常与裴蜀定理混淆）的知识，该定理指出：

$Q(x) = {P(x)-P(r) \over x-r}$

如果从 P(x)减去 P(r)，再除以 x-r，除法应该没有余数，从而得到商多项式 Q(x)。除了 P(r)，证明者还向验证者发送了对 Q(τ) 的承诺。现在验证者有 P(τ)、Q(τ)、r 和 P(r)。由于除法本身不是在椭圆曲线上定义的，因此承诺 P 和 Q（椭圆曲线上的点）要经过一系列变换，以便验证者确认等式的有效性。

$Q(x) = {P(x)-P(r) \over x-r}$

$Q(\tau) = {P(\tau)-P(r) \over \tau-r}$

$(\tau -r)Q(\tau) = P(\tau) - P(r)$

验证者不知道 τ，但他从证明者那里得到了 [Q(τ)] 和 [P(τ)] 的承诺。将等式两边乘以生成点 [G]，情况就变得更加简单了。

$(\tau -r)Q(\tau)[G] = P(\tau)[G] - P(r)[G]$

验证者知道 [Q(τ)] 和 [P(τ)] - 与 Q(τ) 和 P(τ) 相对应的承诺乘以 [G]。由于已知 P(r)，验证者也可以计算 P(r)[G]。为了解决 (τ-r)[G] 问题，我们采用了椭圆曲线配对技术。

$e: \mathbb{G}_1 * \mathbb{G}_2 \to \mathbb{G}_{\mathbb{T}}$

$e:{kG_1,G_2} = e(G_1,kG_2)$ 

函数 e 代表双线性配对，它从两个独立的椭圆曲线群中各取一个点，将它们 "配对"，生成第三个目标群中的一个元素。这个配对函数的双线性性质是：e(k⋅G1,G2)=e(G1,k⋅G2)，其中 k 是标量，G1,G2 分别是两个群中的点。这一特性意味着，在应用配对函数之前，先将一群中的点乘以 k，相当于先应用配对函数，然后在目标群中将其结果乘以 k。

$(\tau - r)Q(\tau)[G_1] = P(\tau)[G_1] - P(r)[G_1]$

$e((\tau-r)[G_1],Q(\tau)[G_2])=e([P(\tau)]_1-[P(r)]_1,[G_2])$

$e(Q(\tau)[G_1],(\tau-r)[G_2])=e([P(\tau)]_1-[P(r)]_1,[G_2])$

$e(Q(\tau)[G_1],(\tau [G_2]-r[G_2]))=e([P(\tau)]_1-[P(r)]_1,[G_2])$

在双线性配对的背景下：

1. 我们可以确定，之前计算的所有元素都映射到曲线 G1 上的点。
2. 当我们提到配对过程中的 "乘法 "时，为了使 (τ-r)Q(τ) 项与配对函数 e 相互作用，我们首先将 (τ-r) 与 G1 的生成点相乘，将其映射到曲线 G1 上，同样地，将 Q(τ) 映射到曲线 G2 上。
3. 配对函数的交换属性允许我们翻转标量 (τ-r) 与承诺 Q(τ)，而不影响结果。
4. 然后，我们应用分配律来 "打开括号"，也就是将乘法分配到配对运算中的各个项上。

现在我们可以说，验证者知道 $[Q(τ)]_1$、 $[P(τ)]_1$ 和 $[P(r)]_1$，也能计算 $r[G2]$，因为 $r$ 是已知的。至于 $τ[G2]$--这个点应该来自可信设置，是通用参考字符串（CRS）的一部分。

$CRS = \lbrace G, {\tau}^1G,{\tau}^2G,….,{\tau}^nG\rbrace ,\tau G_2$

Updated Trusted Setup

$e([Q(\tau)]_1,[\tau]_2-[r]_2)=e([P(\tau)]_1-[P(r)]_1,[G_2])$

![Untitled](zkSNARKs%20%E7%9A%84%E5%BA%95%E5%B1%82%E2%80%94%E2%80%94PLONK%20%E5%8D%8F%E8%AE%AE%EF%BC%9A%E7%AC%AC%201%20%E9%83%A8%E5%88%86%202586002046bb457cb9365b27ef552368/Untitled%201.png)

有了这些元素，验证者就能检查零知识证明的最终等式是否成立。

## **Bathed Polynomial Commitment Schema**

在 PLONK 中，证明者不仅需要承诺一个多项式，还需要承诺多个多项式。虽然理论上证明者和验证者可以使用上述模式逐一处理所有承诺，但 PLONK 的创建者设计了一种经过修改的模式，允许在一个步骤内承诺多个多项式。这种方法被称为 "线性独立"（Linear Independence）。

假设我们有三个多项式 P1(x)、P2(x) 和 P3(x)，我们的目标是证明每个多项式在某个值 r 时的值都为零。为了在一个步骤内高效地证明这一点，我们可以构建一个新的多项式来封装 $P_1(x)$、 $P_2(x)$ 和  $P_3(x)$。

$F(x) = P_1(x)+ P_2(x) + P_3(x) = 0$

新多项式 $F(x)$ 是 $P_1(x)$、 $P_2(x)$ 和 $P_3(x)$ 的组合。如果我们选择一个值 $r$，使 $P_1(r)$、 $P_2(r)$ 和 $P_3(r)$ 在求值时分别得到 2、3 和 -5 的结果，我们就会遇到一个问题。这些求值的总和为零，这可能会错误地暗示每个多项式在 r 处的求值都为零，而实际上它们都不是。这是一个潜在的问题，因为我们的目的是证明每个多项式在 r 处都等于零，而不仅仅是它们的和。

![Untitled](zkSNARKs%20%E7%9A%84%E5%BA%95%E5%B1%82%E2%80%94%E2%80%94PLONK%20%E5%8D%8F%E8%AE%AE%EF%BC%9A%E7%AC%AC%201%20%E9%83%A8%E5%88%86%202586002046bb457cb9365b27ef552368/Untitled%202.png)

为了保证每个多项式 $P_1(x)$、 $P_2(x)$ 和 $P_3(x)$ 在特定点 $r$上分别等于零，我们选择一个非零常数 v（例如 v=2）,并用它来以递增幂的方式对多项式进行缩放。然后，我们定义新的多项式 F(x) 为 $F(x)=v^0P_1(x)+v^1P_2(x)+v^2P_3(x)$ 。当 F(r) 被求值且结果为零时，这意味着 P1(r)、P2(r) 和 P3(r) 都必须为零，因为 v 不为零，而且多项式是以 v 的不同幂来缩放的，这使得它们线性独立。通过这种巧妙的方法，我们可以在一个综合方程中确认 $P_1(x)$、 $P_2(x)$ 和 $P_3(x)$  的各个零点。

在下一篇文章中，我们将讨论其他几个值得关注的方面，然后再开始协议的详细工作。