# Halo and Accumulation

在上一篇文章中，我们介绍了递归证明组合的概念，即用一个 SNARK（外 SNARK）来证明另一个 SNARK（内 SNARK）提供的证明是正确的。我们提供了一个简短的证明，用于计算相应证明上的内部 SNARK 验证电路。这可用于增量可验证计算（IVC），在这种情况下，我们有一连串的计算步骤，并希望验证所有步骤的正确执行。我们不是为整个计算提供证明，而是在每一步都生成一个 SNARK，证明该步骤在上一步的输出上正确完成，并且上一步 SNARK 的验证电路接受了上一步的证明。

# **How efficient is recursive proof composition?**

让我们先来仔细看看这个方案的效率。由于待证明语句涉及验证器本身的电路，因此待证明语句的大小很容易爆炸。如果我们采用 SNARK，验证器电路与待证明语句的大小成线性关系（比如说它是一个常数𝒸的倍数），由于每个验证器都将进入下一步的语句，证明工作量将呈指数增长。更确切地说，对于给定语句，验证器的大小将是𝒸 的倍数。

然而，下一步将包括对验证器检查出的语句的证明，因此验证器电路将成为下一个待证明语句的一部分，使其验证器电路的大小再乘𝒸 倍。反过来，它的验证电路的大小也会增加 𝒸 倍，等等。

`这里大概就是说你把证明递归压缩了，你的验证就要相应的复杂`

为了使其可行并避免验证电路呈指数级增长，我们需要确保验证电路真正小于它所断言的计算。我们称之为 "完全简洁"。然而，这对我们可以使用的 SNARKS 及其安全假设造成了严重限制。

我们必须强制接受这些 SNARK 提出的所有要求，比如 SNARK 所要求的具有亚线性验证时间的可信设置。可信设置是一种程序，只需执行一次，就能生成证明者和验证者共享的数据。随后，每次生成/验证证明时都将使用该设置。这很麻烦，但没有办法绕过它，因为允许非指数增长 IVC 的 SNARKS 都需要它。

# **Accumulate and accelerate**

我们的想法是将每一步中的困难部分推迟到后面的某一步，这样我们就可以将所有推迟的部分累加为一个单一的困难部分实例，而这个实例不会随着每一步的增加而增加。

因此，与其在 n 个步骤中做 n 次繁重的工作，不如在所有步骤中只做一次。

首先，我们来确定验证步骤中计算量较大的部分。在大多数 SNARK 中，这就是打开 `open`多项式承诺这一步。接下来，我们将快速介绍多项式承诺。

# **Polynomial commitments**

跳过

# **Say Hello to Halo**

Bowe, Grigg and Hopwood 在（Halo）中提出了这一想法，即允许验证者推迟线性时间的多项式承诺opening检查，并在最后将这些检查累加到一个单一的此类操作中，从而加快递归组合的速度。

*Halo is the first practical example of recursive proof composition without a trusted setup, using the discrete log assumption over normal cycles of elliptic curves.*

由于无需在每个验证步骤中执行线性时间计算，我们可以利用更多 SNARK，甚至是验证性能不佳的 SNARK。特别是，我们现在能够使用不需要可信设置的 SNARK，而且还能高效地完成！

在 Halo 中，检查多项式承诺的开放性要求的任务变成了两步程序：

1.  A fast one that is outputting a pair consisting of a polynomial and a commitment to it; and
2. An expensive step checking the polynomial-commitment pair.

因此，要验证opening，我们需要创建pair（快速）并检查（昂贵）。好消息是，如果承诺方案是加法同态的，那么昂贵的步骤可以很容易地累积起来。

假设有几个步骤 2 的实例，那么就有几对 $(f_i, C_i)$多项式 $f_i$和它们的承诺 $C_i (f_i, C_i)$。

我们不必分别验证每一对（检查 C₁ 是否是 f₁ 的承诺，C₂ 是否是 f₂ 的承诺，等等），而是可以取多项式的随机线性组合和承诺的相同线性组合。如果所有的承诺都核对无误，那么由于多项式承诺方案是加法同态的，承诺的线性组合就是相应的多项式线性组合的承诺。

这些困难的语句会被积累起来，并在最后一次性得到证明。 `只要我们同时证明积累过程是正确的`，就可以了！虽然验证电路的计算量很大，但由于我们只需对大量步骤进行一次验证，因此成本是可以摊销的。因此，我们才有能力使用带有昂贵验证器的 SNARK，另一方面，它还能让我们在没有可信设置和更简单安全假设的情况下也能正常工作。

Nova 将这一理念发挥到了极致：不是部分步骤，而是整个验证步骤都被推迟。这是通过使用一种新引入的基本原理--折叠方案--来实现的，这是一种将两个步骤的验证简化为一个步骤的验证的优雅方法。

`每一步都使用折叠方案将待验证的新语句折叠成运行语句。只需验证两点就足够了：第一，所有重复折叠后的最终语句都能通过校验；第二，每一步的折叠都是正确执行的。`

第一个步骤只在最后完成一次。第二步成本低廉，因此每一步产生的开销很小。