# Recursive SNARKs and Incrementally Verifiable Computation (IVC)

Nova是一个快速的递归snark(**S**uccinct **N**on-interactive **Ar**gument of **K**nowledge)。SNARK 是一种加密证明系统，它能让证明者用简短的证明和简洁的验证向验证者证明一个语句，而递归 SNARK 则能产生证明先前证明的语句的证明。

在这篇文章中，我们将介绍合成 SNARKs（递归 SNARKs）这个美丽的想法，尝试解释我们从合成中获得了什么，以及它如何帮助实现增量可验证计算。

在接下来的文章中，我们将继续了解递延( `deferral`)的作用（Halo 和其他积累 `accumulationf方案`背后的理念）、折叠的重要概念（Nova 的主要成分）。

# **A fast introduction to SNARKs**

SNARK允许不受信任的证明者让验证者相信它 "知道 "一个满足特定属性的见证ω。例如，证人可以是计算的执行轨迹；证明者将证明计算的正确性，从而证明其输出的正确性。

真正令人着迷的是，我们可以用这样的方式做到这一点：

- 简洁：证明简短，核查人员只需做很少的工作，在某些情况下甚至比读取证人证词的工作量还要少；
- 非交互式：任何人都可以验证证明并确信其正确性，因为它不涉及与验证者的任何交互；
- 可能是零知识：证明不会泄露证人的任何信息。

# **Recursive SNARKs**

与验证冗长的计算相比，SNARK 只需验证更短的计算正确性证明即可。

但为什么要到此为止呢？难道我们不能再进一步，使用 SNARK 将证明的验证简化为计算正确性证明的正确性验证吗？这个想法将我们直接引向 SNARK 组合和递归 SNARK 。  `重点`

许多计算机科学专业的大一学生在第一次接触递归时都惊呆了--函数的定义怎么会包括要定义的函数呢？同样，消化递归 SNARK 可能也需要一些时间：与其说我们在证明 "证人的知识"，不如说我们在证明 "证人的知识"。 `rather than proving knowledge of a witness, we have proof of knowledge of a “proof of knowledge of a witness”.`

经过一番思考后，我们确实很自然地想到了这一点。使用 SNARK，我们可以为计算的正确性创建一个证明 π，也就是说，我们可以证明我知道一个证人 ω，在这个证人上运行计算后，我们将得到一个给定的结果。这个计算被编码为一个电路 𝐶。验证者可以以证明 π 作为输入，正确运行验证算法，从而确信证明的有效性。

现在，这种验证算法本身也可以编码成电路。以证明 π 为输入（见证）的验证算法给出了接受结果 "这一事实可以用另一个 SNARK 来证明。因此，第二个 SNARK 被称为外 SNARK，它证明第一个 SNARK（内 SNARK）对证明 π 的验证算法是正确的。

这样，内层 SNARK 的验证算法就成了外层 SNARK 的电路，而内层 SNARK 验证者提供的证明就成了外层 SNARK 的见证witness。

![Untitled](Recursive%20SNARKs%20and%20Incrementally%20Verifiable%20Comp%20716096563c8642f09d869c6fe138df24/Untitled.png)

# **What do we gain? The optimal blend**

对于常规 SNARK，有各种性能衡量标准，包括证明者的成本、验证者的成本和证明的长度。可以预料的是，这些参数之间总是存在权衡。

然而，通过组合合适的 SNARK，我们可以希望从两方面获益：我们从一个 SNARK（这将是组合中的内部 SNARK）开始，证明者（一个具有快速证明者的 SNARK）的成本较低。一般来说，这会产生一个很长的证明。我们可以使用具有简短证明和快速验证功能的第二个 SNARK（外 SNARK）来断言内 SNARK 的验证电路会接受内 SNARK 验证者提供的长证明，而不是将这个长证明输入验证器。因此，对于组成的 SNARK，在证明者方面，我们将受益于内部 SNARK 的快速证明性能，而在验证者 SNARK 方面，我们将受益于外部 SNARK 的快速验证性能和简短证明。

如果要证明的语句具有重复/迭代结构（由重复应用数量有限的函数组成），那么组合和由此产生的递归 SNARK 就会成为一种有价值的工具。我们将在本篇文章的其余部分讨论这个问题。让我们先来介绍增量可验证计算 `incrementally Verifiable Computation`（IVC）。

# **Incrementally Verifiable Computation (IVC)**

假设计算由重复应用同一个函数 F 组成。函数 F 的输入是前一次应用 F 的输出，可能还有一些额外的输入（提示 `hints`）。

一个突出的例子就是处理区块链上的交易--根据新的交易 T 更新区块链的状态 s。函数 F 将区块链的当前状态作为输入，并返回更新后的状态。交易作为附加输入。F 的输出作为输入输入到 F 的另一个实例中，以便处理下一笔交易。

因此，重复应用的函数将当前状态和事务作为输入，然后返回更新后的状态。更新后的状态再次输入相同的函数，并将新的事务作为输入。

更正式地说，我们有：

$S_n = F^{(N)}(s_0)$

更精确地：

$S_{i+1} = F(T_i,s_i)， for i=0,…,n-1$

$S_n = F(T_{n-1},F(T_{n-2},F(…F(T_1,F(T_0,s_0)))))$

![Untitled](Recursive%20SNARKs%20and%20Incrementally%20Verifiable%20Comp%20716096563c8642f09d869c6fe138df24/Untitled%201.png)

我们可能需要为这种计算的正确执行提供证明。在上面的例子中，区块链的状态会根据接收到的交易进行更新，这种证明可以帮助我们避免在每次有新节点加入区块链时重复处理所有交易。节点只需验证所提供的正确性证明即可

这样做有几个困难。由于迭代次数可能非常多，计算时间可能非常长，为大量计算提供证明将非常昂贵。更重要的是，迭代可能会一直持续下去。

在函数 F 的每次新应用之后，我们都需要从头开始为整个计算生成新的证明。此外，要开始为 𝓃 次迭代生成证明，我们必须等到 𝓃 次迭代结束（在区块链示例中，我们必须等到所有交易完成后才能开始生成证明）。

理想情况下，我们希望能够在每一步之后更新计算正确性证明（以增量方式建立证明），并能够在任何给定点验证其正确性，同时证明/验证者工作的长度不会持续增加。

这让我们想到了增量可验证计算（IVC）。由于计算的迭代结构，我们显然可以为 F 的每个应用创建一个单独的证明，即 πᵢ 证明第 i 步的计算是正确的。但事实上，我们可以把这些SNARK组成一个证明πᵢ，这样证明πᵢ不仅断言了第i步的正确性，而且证明πᵢ-₁的验证也是正确的，也就是说，它是以下两个事实的证明：

1. 从 s₀ 出发，经过 i -1 步到达 sᵢ-₁ 的证明是正确的
2. 将 F 应用于 sᵢ-₁（以及附加输入），得到 sᵢ

换句话说，我们用应用于上一步证明的验证电路来增强每一步的计算 F。这意味着，通过验证最后一个证明，我们可以确定最后一步是正确的，并且我们将通过嵌入计算的验证电路验证证明 πᵢ -1 。因此，给定的步骤和输入的内容都是正确的。

验证π-₁后，我们知道第 i -1 步是正确的，证明πᵢ-₂也通过了验证，这反过来又证明了前一步和输入证明的正确性，如此循环，直到第一步。

![Untitled](Recursive%20SNARKs%20and%20Incrementally%20Verifiable%20Comp%20716096563c8642f09d869c6fe138df24/Untitled%202.png)

# **What’s next?**

验证电路被嵌入到每个步骤中，它的成本很高，因为它涉及到以多项式承诺的方式检查开放声明（下一次再详述）。

这就是 Halo 和其他累积 `accumulation`方案背后的理念：推迟 `deferring`和合并昂贵的部分。Nova 将这一理念发挥到了极致：整个验证步骤都被推迟。这是通过使用一种新引入的基元（称为折叠方案）来实现的--这是一种将整个步骤的两个实例（以及通过重复应用的所有实例）折叠为单一实例的优雅方法。