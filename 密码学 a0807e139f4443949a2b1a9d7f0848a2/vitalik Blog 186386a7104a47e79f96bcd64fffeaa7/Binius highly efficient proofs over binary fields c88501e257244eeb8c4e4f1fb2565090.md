# Binius: highly efficient proofs over binary fields

STARK的高效其中一个关键原因是基于椭圆曲线的SNARK需要在256位整数上运行才安全，而STARK可以使用更小的域，首先是 [`Goldilocks field`](https://polygon.technology/blog/plonky2-a-deep-dive) 64位，现在是用了 [`Mersenne31 and BabyBear`](https://blog.icme.io/small-fields-for-zero-knowledge/) 31位。Plonky2用了Goldilocks field，证明时快了百倍。

**一个自然而然的问题是：我们能否顺应这一趋势，通过直接在 0 和 1 上运行，构建运行速度更快的证明系统？本文讲的是为什么小域会让产生证明更高效，为什么二进制域功能强大以及Binius让二进制域有效的技巧**

![Untitled](Binius%20highly%20efficient%20proofs%20over%20binary%20fields%20c88501e257244eeb8c4e4f1fb2565090/Untitled.png)

# 回顾有限域

![Untitled](Binius%20highly%20efficient%20proofs%20over%20binary%20fields%20c88501e257244eeb8c4e4f1fb2565090/Untitled%201.png)

将运算控制在小范围之内，即使对有限域中的百万级多项式进行求值，也永远不会得到该集合之外的答案。

除法用费马小定理去计算。

素数域是最常见的有限域，但还有另一种类型：扩域。复数就是扩域的例子。

当我们开始处理小域时，素数域的扩展对于维护安全性变得越来越重要，而二进制域（Binius 使用的域）完全依赖于扩展才具有实用性。

# 回顾算术电路

不管是SNARK还是STARK，在证明计算机程序的方法都是算术化。

简单例子：证明我计算出了Fibonacci数列的第100个数字。用多项式编码Fibonacci数列 $F(x+2)=F(x)+F(x+1)$， $x = \{0,1,…,98\}$，我给你提供商多项式：

$H(x)={F(x+2)-F(x)-F(x+1) \over Z(x)}$

$Z(x) = (x-0)*(x-1)*…*(x-98)$，只要我能提供有效的 $F$和 $H$满足这个等式，那么就可以证明 $F$在这个区间一定满足 $F(x+2)=F(x)+F(x+1)$，那么只要再证明 $F$满足 $F(0)=F(1)=1$,我就可以证明 $F(100)$就是第100个Fibonacci数。

如果要证明更复杂的情况，那就把 $F(x+2)=F(x)+F(x+1)$替换为更复杂的等式。 $F(x+1)$是状态机中  $F(x)$的下一个状态

所有 SNARKs 和 STARKs 都基于这一理念，即使用多项式（有时是向量和矩阵）上的简单方程来表示各个值之间的大量关系。并不是所有的计算方法都以上述方式检查相邻计算步骤之间的等价性：例如，PLONK 和 R1CS 就没有这样做。但许多最高效的计算方法都会这样做，因为多次执行相同的检查（或相同的几项检查）更容易最大限度地减少开销

# **Plonky2: from 256-bit SNARKs and STARKs to 64-bit... only STARKs**

五年前，对不同类型零知识证明的合理总结如下。有两种类型的证明：（基于椭圆曲线的）SNARK 和（基于哈希值的）STARK。从技术上讲，STARKs 是 SNARK 的一种，但在实践中，人们通常只用 "SNARK "来指基于椭圆曲线的证明，而用 "STARK "来指基于哈希结构的证明。SNARKs 体积小，因此可以快速验证，并很容易安装到链上。STARKs 体积大，但不需要可信设置，而且具有量子抗性。

![Untitled](Binius%20highly%20efficient%20proofs%20over%20binary%20fields%20c88501e257244eeb8c4e4f1fb2565090/Untitled%202.png)

STARK 的工作原理是将数据视为多项式，计算该多项式在大量点上的值，并将扩展数据的梅克尔根作为 "多项式承诺"。

这里有一段关键的历史，那就是基于椭圆曲线的 SNARKs 最先被广泛使用：STARKs 直到大约 2018 年才因为 FRI 的出现，变得足够高效，而那时 Zcash 已经运行了一年多。基于椭圆曲线的 SNARK 有一个关键限制：如果要使用基于椭圆曲线的 SNARK，那么这些方程中的算术运算必须使用椭圆曲线上的点数的整数模。这是一个很大的数，接近 $2^{256}$,比如 BN128曲线使用 $21888242871839275222246405745257275088548364400416034343698204186575808495617$

但我们实际计算使用到的大多是“小数”：如果你用自己喜欢的语言编写一个 "真正的 "程序，它所处理的大部分内容都是计数器、for 循环中的索引、程序中的位置、代表 "真 "或 "假 "的各个位以及其他几乎总是只有几位数长的内容。

即使你的 "原始 "数据是由 "小 "数组成的，证明过程也需要计算商、扩展、随机线性组合以及数据的其他变换，这些变换会导致等量或更大数量的对象，平均而言，这些对象与你的域的完整大小一样大。这就造成了一个关键的低效率问题：要证明 n 个小数值的计算结果，就必须对 n 个大得多的数值进行更多的计算。起初，STARK 继承了 SNARK 使用 256 位字段的习惯，因此也存在同样的低效问题。

![Untitled](Binius%20highly%20efficient%20proofs%20over%20binary%20fields%20c88501e257244eeb8c4e4f1fb2565090/Untitled%203.png)

*一些多项式求值的里德-所罗门扩展。尽管原始值很小，但额外的值都会膨胀到域的全部大小（例子中为 $2^{31}-1$）*

2022 年，Plonky2 发布。Plonky2 的主要创新在于用较小的质数进行算术运算: $2^{64}-2^{32}+1=18446744069414584321$.现在，每个加法或乘法运算只需几条指令就能在 CPU 上完成，所有数据的散列速度比以前快 4 倍。但这样做也有一个问题：这种方法只适用于 STARK。如果您尝试在这么小的椭圆曲线上使用 SNARK，那么椭圆曲线就会变得不安全。

为了继续保证安全，Plonky2 还需要引入扩展字段。检查算术方程式的一项关键技术是 "随机点取样"：如果你要检查 $H(x)*Z(x)$是否等于 $F(x+2)-F(x+1)-F(x)$，你可以挑选随机数 $r$，提供多项式承诺开放证明 $H(r),Z(r),F(r),F(r+1)和F(r+2)$,并证明 $H(r)*Z(r)$等于 $F(r+2)-F(r+1)-F(r)$。如果攻击者能提前猜到取样点，就能欺骗证明系统--这就是为什么取样点必须是随机的。但这也意味着，必须从一个足够大的集合中抽取坐标样本，使攻击者无法通过随机机会猜出取样点。

我们可以从扩展域上取样。比如我们可以定义 $y$为 $y^3=5$，采取以下组合 $1,y,y^2$。这样，取样点总数又增加到大约 $2^{93}$.证明者计算的大部分多项式并不进入这个扩展域，它们只是使用整数取模 $2^{31}-1$。因此，你仍然可以通过使用小域来获得效率提升。但是，随机点检查和 FRI 计算会深入到更大的域中，以获得所需的安全性。

# **From small primes to binary**

计算机通过将较大的数字表示为 0 和 1 的序列来进行运算，并在这些比特的基础上构建 "电路 "来计算加法和乘法等运算。计算机特别适合使用 16 位、32 位和 64 位整数进行计算。模数，如 $2^{64}-2^{32}+1$ 和 $2^{31}-1$，之所以选择它们，不仅仅是因为它们符合这些条件，也因为你可以进行模乘 $2^{64}-2^{32}+1$通过普通32位乘法，并在一些地方按位移位和复制输出；这篇文章很好地解释了其中的一些技巧。

然而，更棒的是直接用二进制进行计算。如果加法可以 "只是 "XOR，而无需担心从一个比特位置加 1 + 1 的溢出 "携带 "到下一个比特位置呢？如果乘法也能以同样的方式提高并行性呢？而这些优势都是在只用一位就能表示真假值的基础上实现的。

Binius 正是要抓住直接进行二进制计算的这些优势。Binius 团队在 [zkSummit 演讲](https://docs.google.com/presentation/d/1WuTiof1BiaL6vB50CSeb-hvi5H4j_oqUt19-sZTQEB4/edit#slide=id.g2c9c013854e_0_95)中的一张表格显示了效率的提高：

![Untitled](Binius%20highly%20efficient%20proofs%20over%20binary%20fields%20c88501e257244eeb8c4e4f1fb2565090/Untitled%204.png)

尽管 "大小 "大致相同，但 32 位二进制域运算所需的计算资源比 31 位梅森素数域运算少 5 倍。

# **From univariate polynomials to hypercubes**

假设我们相信这个推理，并希望用比特（0 和 1）来处理所有事情。我们究竟该如何承诺一个代表十亿位的多项式呢？

在这里，我们面临着两个实际问题：

1. 要让多项式代表大量数值，这些数值需要在多项式求值时可以访问：如上面的斐波那契例子， $F(0),F(1),…,F(100)$，而在更大的计算中，指数将高达数百万。而我们使用的域需要包含达到这个规模的数字。
2. 要证明梅克尔树（所有 STARK 都是这样做的）中承诺的值的任何内容，都需要对其进行里德-所罗门编码 `Reed-Solomon`：扩展n个值到8n个值，利用冗余来防止恶意验证者在计算过程中伪造一个值进行作弊。这还需要一个足够大的区域：要将一百万个值扩展到八百万个，就需要八百万个不同的点来评估多项式。

Binius 的一个重要理念就是分别解决这两个问题，并通过两种不同的方式来表示相同的数据。首先是多项式本身。基于椭圆曲线的 SNARK、2019 年代的 STARK、Plonky2 和其他系统通常处理单变量多项式： $F(x)$。Binius从[Spartan](https://eprint.iacr.org/2019/550.pdf) protocol汲取了灵感，采用多变量多项式： $F(x_1,x_2,…,x_3)$

事实上，我们用评估的 "hypercube "来表示整个计算轨迹，每个 $x_i$都是0或者1.例如，如果我们想表示斐波那契数列，而且我们仍在使用一个足够大的域来表示这些数列，那么我们可以将前十六个数列想象成类似下面的样子：

![Untitled](Binius%20highly%20efficient%20proofs%20over%20binary%20fields%20c88501e257244eeb8c4e4f1fb2565090/Untitled%205.png)

$F(0,0,0,0)=1$， $F(1,0,0,0)=1$, $F(0,1,0,0)=2$,….., $F(1,1,1,1)=987$

给定这样一个求值的超立方体，正好有一个多线性（每个变量的度数都是 1）多项式可以产生这些求值。因此，我们可以把这组求值看作是多项式的代表；实际上，我们根本不需要费心计算系数。

当然，这个例子只是为了说明：实际上，使用超立方体的全部意义在于让我们使用单个比特。计算斐波那契数的 "原生 "方法是使用一个更高维的立方体，使用每组例如 16 个比特来存储一个数字。这需要在比特上实现整数加法，但对于 Binius 来说并不难。

现在，我们来谈谈擦除编码。STARK 的工作原理是：你有n个值，Reed-Solomon将其扩展到更多的值(通常是8n，在n到32n之间)，然后从扩展中随机选择一些梅克尔分支，并对它们进行某种检查。超立方体每个维度的长度为 2。因此，直接扩展它是不现实的：没有足够的 "空间 "从 16 个值中抽取 Merkle 分支。那么我们该怎么做呢？我们假装超立方体是一个正方形！

# **Simple Binius - an example**

*See [here](https://github.com/ethereum/research/blob/master/binius/simple_binius.py) for a python implementation of this protocol.*

让我们举例说明，为了方便起见，我们使用正整数作为域（在实际应用中，这将是二进制域元素）。首先，我们把要提交的超立方体编码为正方形：

![Untitled](Binius%20highly%20efficient%20proofs%20over%20binary%20fields%20c88501e257244eeb8c4e4f1fb2565090/Untitled%206.png)

`注:这里的立方体只是个例子，和上面的Fibonacci立方体没有关系`

现在，我们对正方形进行Reed-Solomon扩展。也就是说，我们将每一行都视为在 $x=\{0,1,2,3\}$位置求值的 3 度多项式，然后在 $x=\{4,5,6,7\}$求值

![Untitled](Binius%20highly%20efficient%20proofs%20over%20binary%20fields%20c88501e257244eeb8c4e4f1fb2565090/Untitled%207.png)

`注：第一行的演示过程 在 $(0,3),(1,1),(2,4),(3,1)$四个点进行拉格朗日插值求多项式，求出多项式之后计算多项式在 $x=\{0,1,2,3\}$的值：`

工具网站：[https://zh.planetcalc.com/8692/](https://zh.planetcalc.com/8692/)

![Untitled](Binius%20highly%20efficient%20proofs%20over%20binary%20fields%20c88501e257244eeb8c4e4f1fb2565090/Untitled%208.png)

![Untitled](Binius%20highly%20efficient%20proofs%20over%20binary%20fields%20c88501e257244eeb8c4e4f1fb2565090/Untitled%209.png)

代入 $x=\{4,5,6,7\}$

![Untitled](Binius%20highly%20efficient%20proofs%20over%20binary%20fields%20c88501e257244eeb8c4e4f1fb2565090/Untitled%2010.png)

请注意，这些数字很快就会爆炸！这就是为什么在实际应用中，我们总是使用有限域而不是常规整数：例如，如果我们使用整数 modulo 11，第一行的扩展将是 $[3,10,0,6]$

如果你想自己扩展和验证这里的数字，可以使用[my simple Reed-Solomon extension code here](https://github.com/ethereum/research/blob/master/binius/utils.py#L123).。

接下来，我们将这些扩展视为列，并将这些列组成一棵 Merkle 树。梅克尔树的根就是我们的承诺。

![Untitled](Binius%20highly%20efficient%20proofs%20over%20binary%20fields%20c88501e257244eeb8c4e4f1fb2565090/Untitled%2011.png)

现在，让我们假设证明者想要证明这个多项式在某一点 $\{r_0,r_1,r_2,r_3\}$上的求值，Binius有一个细微差别，使它比其他多项式承诺方案弱一些：证明者不应该知道或能够猜到$s$直到他们投入 Merkle 根之后（换句话说， $r$应该是一个取决于梅克尔根的伪随机值）这使得该方案在 "database lookup"中失效。但我们实际使用的零知识证明协议一般不需要 "database lookup"；它们只需要在随机评估点检查多项式。因此，这种限制对于我们的目的来说是没有问题的。

假设我们选择 $r=\{1,2,3,4\}$ （多项式在这个点的值为 $-137$,you can confirm it [with this code](https://github.com/ethereum/research/blob/master/binius/utils.py#L100)）

`注：因为没看过多线性多项式的原因这里不会计算，所以我去看了代码,多线性多项式内容后面补一下`

![Untitled](Binius%20highly%20efficient%20proofs%20over%20binary%20fields%20c88501e257244eeb8c4e4f1fb2565090/Untitled%2012.png)

---

---

---

---

现在，我们进入实际的证明过程。我们把 $r$分为两部分，一部分为 $\{1,2\}$代表一行内各列的线性组合， $\{3,4\}$代表行的线性组合，我们计算 "张量乘积"，既包括列的部分：

$\oplus_{i=0}^1(1-r_i,r_i)$

和行的部分：

$\oplus_{i=2}^3(1-r_i,r_i)$

这意味着：每个集合中一个值的所有可能乘积的列表。在行的情况下，我们得到

$[(1-r_2)*(1-r_3),r_2*(1-r_3),(1-r_2)*r_3,r_2*r_3]$

使用 $r=\{1,2,3,4\}$(所以 $r_2=3$和 $r_3=4$)

$[(1-3)*(1-4),3*(1-4),(1-3)*4,3*4] = [6,-9,-8,12]$

现在，我们计算一个新的 "行” $t’$，通过计算现在行的线性组合：

# 扩域

定义 $x^2 = x+1$  无解，引入 $x_0$

![Untitled](Binius%20highly%20efficient%20proofs%20over%20binary%20fields%20c88501e257244eeb8c4e4f1fb2565090/Untitled%2013.png)

不断从 $F_2$扩域到 $F_{2^2}$再到  $F_{2^3}$以此类推

塔结构扩域，并不是唯一的扩域方式。

# 塔域的拉格朗日插值

重点就是都要在塔域内计算，不要在素数域计算了。

![1jpg.jpg](Binius%20highly%20efficient%20proofs%20over%20binary%20fields%20c88501e257244eeb8c4e4f1fb2565090/1jpg.jpg)